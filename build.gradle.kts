import java.text.SimpleDateFormat
import java.util.Date
import org.gradle.kotlin.dsl.support.delegates.DependencyHandlerDelegate

buildscript {
    repositories {
        // These repositories are only for Gradle plugins, put any other repositories in the repository block further below
        maven("https://repo.spongepowered.org/repository/maven-public/")
        mavenCentral()
    }
    dependencies {
        classpath("org.spongepowered:mixingradle:0.7.+")
    }
}

plugins {
    alias(libs.plugins.eclipse)
    alias(libs.plugins.idea)
    alias(libs.plugins.forgeGradle)
    alias(libs.plugins.mixin)
}

// mod loader
val minecraftVersion: String by project
val minecraftVersionRange: String by project
val forgeVersion: String by project
val forgeVersionRange: String by project
val loaderVersionRange: String by project

// mod mapping
val modMappingChannel: String by project
val modMappingVersion: String by project

// mod metadata
val modId: String by project
val modName: String by project
val modLicense: String by project
val modAuthors: String by project
val modDescription: String by project

// jei / emi switcher
val useJei: Boolean = project.findProperty("useJei") == "true"

group = "com.sysnote8"
version = System.getenv("MOD_VERSION") ?: "0.0.0-indev"

base {
    archivesName = modId
}

java {
    toolchain.languageVersion = JavaLanguageVersion.of(17)
}

minecraft {
    // The mappings can be changed at any time and must be in the following format.
    // Channel:   Version:
    // official   MCVersion             Official field/method names from Mojang mapping files
    // parchment  YYYY.MM.DD-MCVersion  Open community-sourced parameter names and javadocs layered on top of official

    mappingChannel = modMappingChannel
    mappingVersion = modMappingVersion

    // enableEclipsePrepareRuns = true
    // enableIdeaPrepareRuns = true

    copyIdeResources = true

    // generateRunFolders = true

    // accessTransformer = file("src/main/resources/META-INF/accesstransformer.cfg")

    runs {
        configureEach {
            workingDirectory(project.file("run"))

            // Recommended logging data for a userdev environment
            // The markers can be added/remove as needed separated by commas.
            // "SCAN": For mods scan.
            // "REGISTRIES": For firing of registry events.
            // "REGISTRYDUMP": For getting the contents of all registries.
            property("forge.logging.markers", "REGISTRIES")

            // Recommended logging level for the console
            // You can set various levels here.
            // Please read: https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
            property("forge.logging.console.level", "debug")

            mods {
                create(modId) {
                    source(sourceSets.main.get())
                }
            }
        }

        create("client") {
            property("mixin.env.remapRefMap", "true")
            property("mixin.env.refMapRemappingFile", "$projectDir/build/createSrgToMcp/output.srg")
            // Comma-separated list of namespaces to load gametests from. Empty = all namespaces.
            property("forge.enabledGameTestNamespaces", modId)
        }

        create("server") {
            property("forge.enabledGameTestNamespaces", modId)
            args("--nogui")
        }

        // This run config launches GameTestServer and runs all registered gametests, then exits.
        // By default, the server will crash when no gametests are provided.
        // The gametest system is also enabled by default for other run configs under the /test command.
        create("gameTestServer") {
            property("forge.enabledGameTestNamespaces", modId)
        }

        create("data") {
            // example of overriding the workingDirectory set in configureEach above
            workingDirectory(project.file("run-data"))

            // Specify the modid for data generation, where to output the resulting resource, and where to look for existing resources.
            args("--mod", modId, "--all", "--output", file("src/generated/resources/"), "--existing", file("src/main/resources/"))
        }
    }
}

mixin {
    add(sourceSets.main.get(), "$modId.refmap.json")

    config("$modId.mixins.json")
}

// Include resources generated by data generators.
sourceSets.main.get().resources { srcDir("src/generated/resources") }

repositories {
    // flatDir {
    //     dir "libs"
    // }
    exclusiveContent {
        forRepository {
            maven("https://api.modrinth.com/maven") {
                name = "Modrinth"
            }
        }
        forRepositories(fg.repository)
        filter {
            includeGroup("maven.modrinth")
        }
    }

    maven("https://maven.terraformersmc.com/") {
        name = "TerraformersMC"
    }

    maven("https://maven.blamejared.com/") {
        // location of the maven that hosts JEI files since January 2023
        name = "Jared's maven"
    }
    maven("https://modmaven.dev") {
        // location of a maven mirror for JEI files, as a fallback
        name = "ModMaven"
    }
}

val emiVersion: String = "1.1.22+1.20.1"
dependencies {
    minecraft(libs.forge)

    compileOnlyDeobf(libs.bundles.jeiApi)
    compileOnlyDeobf(apiClassifier(libs.emi))

    runtimeOnlyDeobf(
        if (useJei) {
            libs.jei
        } else {
            libs.emi
        },
    )

    implementation(fg.deobf(libs.automobility))

    annotationProcessor(classified(libs.mixin, "processor"))
}

fun DependencyHandler.compileOnlyDeobf(provider: Provider<*>): Dependency? = compileOnly(fg.deobf(provider))

fun DependencyHandler.runtimeOnlyDeobf(provider: Provider<*>): Dependency? = runtimeOnly(fg.deobf(provider))

fun DependencyHandlerDelegate.classified(
    dependencyProvider: Provider<MinimalExternalModuleDependency>,
    classifier: String,
) = variantOf(dependencyProvider) {
    classifier(classifier)
}

fun DependencyHandlerDelegate.apiClassifier(dependencyProvider: Provider<MinimalExternalModuleDependency>) = classified(dependencyProvider, "api")

tasks {
    processResources {
        val props =
            mapOf(
                "minecraft_version" to minecraftVersion,
                "minecraft_version_range" to minecraftVersionRange,
                "forge_version" to forgeVersion,
                "forge_version_range" to forgeVersionRange,
                "loader_version_range" to loaderVersionRange,
                "mod_id" to modId,
                "mod_name" to modName,
                "mod_license" to modLicense,
                "mod_version" to project.version,
                "mod_authors" to modAuthors,
                "mod_description" to modDescription,
            )
        inputs.properties(props)
        filteringCharset = "UTF-8"
        filesMatching(listOf("META-INF/mods.toml", "pack.mcmeta")) {
            expand(props)
        }
    }

    jar {
        manifest {
            attributes(
                "Specification-Title" to modId,
                "Specification-Vendor" to modAuthors,
                "Specification-Version" to "1", // We are version 1 of ourselves
                "Implementation-Title" to project.name,
                "Implementation-Version" to project.version,
                "Implementation-Vendor" to modAuthors,
                "Implementation-Timestamp" to SimpleDateFormat("yyyy-MM-dd HH:mm:ssZ").format(Date()),
            )
        }

        finalizedBy("reobfJar")
    }

    compileJava {
        options.encoding = "UTF-8"
    }
}
